#pragma kernel Kernel_Clear
#pragma kernel Kernel_WaveSimulator
#pragma kernel Kernel_CalculateNormals

// Make sure these match in C#.

#define THREAD_COUNT 8
#define MAX_INPUTS 32

struct Input
{
	int2 coord;
	float radius;
};

StructuredBuffer<Input> inputs;
RWTexture2D<float4> heightTexture;

int inputCount;
uint size;

// DO NOT EXCEED 2.0.

float speed = 1.0;

float decay = 0.99;

// Neighbour pixel offsets: top, bottom, left, right.

#define off_L int2(-1,  0);
#define off_R int2( 1,  0);
#define off_T int2( 0,  1);
#define off_B int2( 0, -1);

// *Somewhat* optional, but can be useful for debugging.

[numthreads(THREAD_COUNT, THREAD_COUNT, 1)]
void Kernel_Clear(uint3 id : SV_DispatchThreadID)
{
	heightTexture[id.xy] = 0.0;
}

[numthreads(THREAD_COUNT, THREAD_COUNT, 1)]
void Kernel_WaveSimulator(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= size || id.y >= size) return;

	int2 id_C = id.xy;
    
	// if (id.x == 0 || id.y == 0 || id.x == size - 1 || id.y == size - 1)
	// {
	//    heightTexture[id_C] = 0.0;
	//    return;
	// }
	
	int2 id_L = id_C + off_L;
	int2 id_R = id_C + off_R;
	int2 id_T = id_C + off_T;
	int2 id_B = id_C + off_B;
	
	double2 height = heightTexture[id_C].xy;
			
	// If the mouse is down, add a wave.
	// Can also just multiply by iMouse.z to avoid the if statement.
	
	//if (iMouse.z > 0.0)
	//{
	//    height.x += smoothstep(1.0, 0.0, length(iMouse.xy - id_C) / inputRadius);
	//}
	
	for (int i = 0; i < inputCount; i++)
	{        
			Input input = inputs[i];
			
			height.x += smoothstep(1.0, 0.0, length(input.coord - id_C) / input.radius);
	}
	
	double height_L = heightTexture[id_L].x;
	double height_R = heightTexture[id_R].x;
	double height_T = heightTexture[id_T].x;
	double height_B = heightTexture[id_B].x;
	
	double neighbourSum = height_L + height_R + height_T + height_B;
	double neighbourAverage = neighbourSum / 4.0;
	
	// The actual propagation...
	// Based off: https://github.com/evanw/webgl-water/blob/master/water.js.
	
	// Move velocity towards local average.    
	// target - current = scaled direction.
	
	height.y += neighbourAverage - height.x;
	height.y *= decay;
	
	// Apply velocity.
	
	height.x += height.y * speed;
	
	heightTexture[id_C] = float4(height, 0,0);
}

[numthreads(THREAD_COUNT, THREAD_COUNT, 1)]
void Kernel_CalculateNormals(uint3 id : SV_DispatchThreadID)
{
	int2 id_C = id.xy;
	int2 id_L = id_C + off_L;
	int2 id_R = id_C + off_R;
	int2 id_T = id_C + off_T;
	int2 id_B = id_C + off_B;
	
	float4 height = heightTexture[id_C];
					
	float height_L = heightTexture[id_L].x;
	float height_R = heightTexture[id_R].x;
	float height_T = heightTexture[id_T].x;
	float height_B = heightTexture[id_B].x;
					
	// Calculate normal based on height differences, storing in .zw.
	
	height.z = (height_L - height_R) * 0.5;
	height.w = (height_T - height_B) * 0.5;
	
	heightTexture[id_C] = height;
}